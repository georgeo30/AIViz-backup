<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<title>Africa Internet Visualizer</title>

<!--Styling of elements on map-->
<style>
  .country-area {
    fill: black;
    stroke: #fff;
  }

  /*.countries*/
  .country-area:hover {
    fill: #cccccc;
  }

  .c2p {
    stroke: green;
    fill: none;
  }

  .same-customer {
    stroke: green;
    fill: none;
  }

  .p2p {
    stroke: red;
    fill: none;
  }

  .same-peer {
    stroke: red;
    fill: none;
  }

  .s2s {
    stroke: turquoise;
    fill: none;
  }

  .same-sibling {
    stroke: turquoise;
    fill: none;
  }

  .asn:hover {
    stroke: blue;
  }

  .IXP {
    fill: rgba(169, 103, 201, 0.7);

  }

  .asn-dot {
    fill: rgb(255, 255, 0, 0.7);

  }
</style>
<!--hamburger Menu, filters and map-->

<body style="background-color: 	#cae7f9;">
  <div class="w3-sidebar w3-bar-block w3-dark-grey w3-animate-left" style="display:none; background-color: white;"
    id="mySidebar">
    <!-- Header and Menu button -->
    <div style="background-color: black; color:white;">
      <button class="w3-button w3-xlarge w3-hover-black w3-bar-item" onclick=" w3_close()">&times;
        <h3 style=" display: inline-block; ">Africa Internet Visualizer</h3></button>
    </div>
    <!-- Border checkbox -->
    <a href="#" class="w3-bar-item w3-button item">
      <div> <input type="checkbox" id="cbborder" name="vehicle1" checked="checked"> <label
          for="vehicle1">Borders</label><br>

        </label></input>
      </div>
    </a>
    <!-- Different Views options -->
    <a class="w3-bar-item">Views</a>

    <!-- Continental View checkbox -->
    <a href="#" class="w3-bar-item w3-button item">
      <div> <input type="checkbox" id="allixpsandasns" onclick="continentalView()" checked="checked">
        <label>Continental View
        </label><br>

        </label></input>
      </div>

    </a>

    <!-- Relationship Views Options -->
    <a class="w3-bar-item">Relationships</a>

    <!-- Peer to peer cb -->
    <a href="#" class="w3-bar-item w3-button item">
      <div> <input type="checkbox" id="p2pcb" onclick="peerToPeer()" checked="checked"> <label>Peer to Peer
        </label><br>

        </label></input>
      </div>

    </a>
    <!-- customer to provider relationship -->
    <a href="#" class="w3-bar-item w3-button item">
      <div> <input type="checkbox" id="c2pcb" onclick="customerToProvider()" checked="checked"> <label>Customer to
          provider
        </label><br>

        </label></input>
      </div>

    </a>
    <!-- sibling to sibling relationship -->

    <a href="#" class="w3-bar-item w3-button item">
      <div> <input type="checkbox" id="s2scb" onclick="siblingToSibling()" checked="checked"> <label>Sibling to Sibling
        </label><br>

        </label></input>
      </div>

    </a>



    <!-- Header and Menu button -->

  </div>
  <div style="background-color: black;">
    <button id="openNav" class="w3-button w3-xlarge w3-hover-black w3-bar-item"
      style="background-color: black; color: white;" onclick="w3_open()">&#9776; <h2 style=" display: inline-block;">
        Africa Internet Visualizer</h1>
    </button>

  </div>
  <div id="main">

    <script>
      //Organizing Side Navigation bar
      function w3_open() {
        document.getElementById("main").style.marginLeft = "25%";
        document.getElementById("mySidebar").style.width = "25%";
        document.getElementById("mySidebar").style.display = "block";
        document.getElementById("openNav").style.display = 'none';
      }
      function w3_close() {
        document.getElementById("main").style.marginLeft = "0%";
        document.getElementById("mySidebar").style.display = "none";
        document.getElementById("openNav").style.display = "inline-block";
      }

      //Border color method
      document.getElementById("cbborder").onclick = function () {
        if (this.checked) {
          var cols = document.getElementsByClassName(/*'countries'*/'country-area');

          for (i = 0; i < cols.length; i++) {
            cols[i].style.stroke = 'white';

          }


        }
        else {
          var cols = document.getElementsByClassName(/*'countries'*/'country-area');
          for (i = 0; i < cols.length; i++) {
            cols[i].style.stroke = 'black';

          }

        }
      };
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/1.6.19/topojson.min.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/topojson.v1.min.js"></script>
    <!--D3 work starts here-->
    <script>

      //Canvas settings
      var width = 1200, height = 800;

      //Projection type
      var projection = d3.geoMercator()
        .translate([width / 2, height / 2])
        .scale(500);

      //Path generator
      var path = d3.geoPath()
        .projection(projection);

      //ASN projection
      var pathTwo = d3.geoPath()
        .projection(projection)
        .pointRadius(5);

      //Add canvas with settings for its height and width, store the reference here in svg
      var svg = d3.select("#main").append("svg")
        .attr("width", width)
        .attr("height", height);

      //Methods used to know what filtering methods must be applied
      var currentView;

      var previousCountry;

      var clickedIxp;
      var customerAsns;
      var countryAsns = [];


      var p2pCheckBox = document.getElementById("p2pcb");

      var c2pCheckBox = document.getElementById("c2pcb");

      var s2sCheckBox = document.getElementById("s2scb");

      //Load data... Should we split this up into callable methods?
      // d3.queue()
      //   .defer(d3.json, "testTopoAfrica.json")
      //   .defer(d3.csv, "ixps.csv", typeIxp)
      //   .defer(d3.csv, "asnTest.csv", typeAsn)
      //   // .defer(d3.csv, "links.csv")
      //   .await(ready);

      //Load data: Alternative
      d3.queue()
        .defer(d3.json, "http://192.168.0.18:8080/testTopoAfrica.json")
        .defer(d3.csv, "http://192.168.0.18:8080/ixps.csv", typeIxp)
        .defer(d3.csv, "http://192.168.0.18:8080/asnTestTwo.csv", typeAsn)
        .defer(d3.csv, "http://192.168.0.18:8080/links.csv")

        .await(ready);

      var ixpsbyid;
      var asnsbyid;
      //Callback after data is loaded
      function ready(error, africa, ixps, asns, links) {

        if (error) throw error;

        //Set id fields as the key for the ixp and asn datasets
        ixpsbyid = d3.map(ixps, function (d) { return d.id; });
        asnsbyid = d3.map(asns, function (d) { return d.id; });


        //Convert each country from the topology file to a geoJson feature
        var features = topojson.feature(africa, africa.objects.testAfrica).features;

        //Add drawing-box that will contain all country drawings (outlines of a country & an onclick method)
        var drawingBox = svg.append("g")
          .attr("class", "drawing-box")

        //Draw countries inside the drawing box using the geoJson features
        drawingBox.selectAll(".country-area") //null is used since no country-area element has been created before
          .data(features)
          .enter()
          .append("path")
          .attr("class", "country-area")
          .attr("d", path)
          .on("click", clickCountry);

        //Add empty country-containers that will contain asn and ixp elements
        var countries = svg.selectAll(".country") //null is used since no country containers have been defined before (no search time -> more efficient )
          .data(features)
          .enter().append("g")
          .attr("class", "country")
          .style("visibility", "visible")
          .attr("id", function (currentFeature) { return currentFeature.properties.country_code });



        svg.selectAll(".IXP").data(ixps).enter().each(function (d, i) {
          var currentCountry = svg.select(`#${d.country}.country`);
          var currentIxp = d;
          currentCountry.append("polygon").attr("points", function () {
            var len = 10;
            var cons = (Math.sqrt(3)) / 2;
            var centerX = projection([d.longitude, d.latitude])[0];
            var centerY = projection([d.longitude, d.latitude])[1];
            return `${centerX - (len * cons)},${centerY + (len / 2)} ${centerX},${centerY - len} ${centerX + (len * cons)},${centerY + (len / 2)}`;
          }).attr("class", "IXP").style("visibility", "inherit").attr("id", function () { return `IXP_${currentIxp.id}` }).on("click", clickIxp)
            .datum(currentIxp);
        });

        svg.selectAll(".ASN").data(asns).enter().each(function (d, i) {
          var sourceAsn = d;
          //console.log(d)
          var currentCountry = svg.select(`#${d.country}.country`);
          currentCountry.append("g").datum(sourceAsn)
            .attr("class", "ASN").style("visibility", "inherit").attr("id", function (d) { return "ASN_" + sourceAsn.id })
            .each(function (d, i) {

              var currentContainer = d3.select(this); //g element 


              var values = ""
              sourceAsn.map.forEach(function (relationshipType, destinationKey, map) { //loop through every key-value pair
                var destinationAsn = asnsbyid.get(destinationKey);
                currentRelationship = { type: "LineString", coordinates: [sourceAsn, destinationAsn] };
                currentContainer.append("path")
                  .attr("d", path(currentRelationship))
                  .attr("class", relationshipType)
                  .style("visibility", "inherit")
                  .attr("destination", destinationAsn.id);

              })


              currentContainer.append("circle")
                .attr("class", function (d) { return `asn-dot` })
                .attr("cx", function (d) { return projection([sourceAsn.longitude, sourceAsn.latitude])[0] })
                .attr("cy", function (d) { return projection([sourceAsn.longitude, sourceAsn.latitude])[1] })
                .style("fill", "rgb(255,255,0,0.7)")
                .style("visibility", "inherit")
                .attr("r", 4);

            });

        });





        // //Set the currentView to continental, this will be used to simplify the transitions for onClick event handlers
        currentView = "continental"

      }; //end of reading files

      // All IXPs and ASNs checkbox
      function continentalView() {
        if (currentView == "national") {
          revertToCountryInherit();
        }
        else if (currentView=="IXP"){
          revertToIXPInherit();
        }
        currentView = "continental";

        var allixpsandasns = document.getElementById("allixpsandasns");

        if (allixpsandasns.checked == true) {

          drawEverything(true);

        } else {
          drawEverything(false); //remove everything
        }

      }



      // Check box for Peer to peer
      //Triggers a call to disable/enable all peer-peer relationships
      function peerToPeer() {
        var visibilityStatus = document.getElementById("p2pcb").checked;
        setType("peer", visibilityStatus);
      }

      // Check box for Customer to provider
      //Triggers a call to disable/enable all customer-provider relationships
      function customerToProvider() {
        var visibilityStatus = document.getElementById("c2pcb").checked;
        setType("customer", visibilityStatus);
      }
      // Check box for sibling to sibling
      //Triggers a call to disable/enable all sibling-sibling relationships
      function siblingToSibling() {
        var visibilityStatus = document.getElementById("s2scb").checked;
        setType("sibling", visibilityStatus);
      }

      //ContinentalView: Enables/disables all realtionships of the specified type 
      //NationalView: Enables/disables relationships for the currently clicked country of the specified type
      function setType(relationshipType, visible) {
        visibilityStatus = (visible) ? "visible" : "hidden";

        if (currentView.toLowerCase() == "continental") {
          svg.selectAll("asn").selectAll(`path.${relationshipType}`).style("visibility", visibilityStatus);
          svg.selectAll("asn").selectAll(`path.same-${relationshipType}`).style("visibility", visibilityStatus);
        }
        else if (currentView.toLowerCase() == "national") {
          svg.selectAll("asn").selectAll(`path.same-${relationshipType}`).style("visibility", function (currentASN) { return (currentASN.country == previousCountry && visible ? "visible" : "hidden") });

        }

      }

      //click IXP
      function clickIxp(d, i) {
        document.getElementById("allixpsandasns").checked = false;
        if (currentView == "national") {
          revertToCountryInherit();

        }

        
        currentView="IXP";
        clickedIxp = d.id;
        showIxp(clickedIxp);
      }


      function showIxp(clickedIxp) {

        //Sets everything on the map to hidden
        svg.selectAll(".country").style("visibility", "hidden");
        // var customerAsns;
        // var countryAsns = [];
        //plots the ixp that was clicked, also gets the customer ASNs of that IXP
        svg.select(`#IXP_${clickedIxp}`).style("visibility", function (value) {
          
            customerAsns = value.customers;
            return "visible";
        });

        //Finding the country for each customer in the customerAsns list
        customerAsns.forEach(function (id) {
          countryAsns.push(asnsbyid.get(id).country);
        });
        //Removing duplicates
        countryAsns = [...new Set(countryAsns)];

        countryAsns.forEach(function (country) {
          svg.select(`#${country}.country`).selectAll(".ASN")
            .each(function (d, i) {
              if (customerAsns.includes(d.id)) {
                d3.select(this).select(".asn-dot").style("visibility", "visible");
                d3.select(this).selectAll("path")
                .each(function(d,i){
                    var destinationAsn = asnsbyid.get(d3.select(this).attr("destination"));
                    if(customerAsns.includes(destinationAsn.id)){
                      d3.select(this).style("visibility","visible");
                    }

                })
                // .style("visibility", function (d) {
                //   var destinationAsn = asnsbyid.get(d3.select(this).attr("destination"));
                //   return customerAsns.includes(destinationAsn.id) ? "visible" : "inherit";

                // })
              }
            })


        })



      }

      //Changes state variables and makes a call to the eventhandler by passing in the currently clicked country
      function clickCountry(d, i) {
        document.getElementById("allixpsandasns").checked = false;
        if (currentView == "national") {
          revertToCountryInherit();
        }
        else if (currentView=="IXP"){
          revertToIXPInherit();
        }
      

        var clickedCountry = d.properties.country_code;
        previousCountry = d.properties.country_code;

        currentView = "national";

        // drawEverything(true);

        showCountry(clickedCountry);

      }
      //Ensures that only ASN's & IXP's and it's internal relationships are displayed by using a passed in country reference
      function showCountry(country) {

        //svg.selectAll(".country").selectAll("path").style("visibility", "hidden");
        svg.selectAll(".country").style("visibility", function (value) { return value.properties.country_code == country ? "visible" : "hidden" });
        svg.select(`#${country}.country`).selectAll("path").style("visibility", function (d) {

          var destinationAsn = asnsbyid.get(d3.select(this).attr("destination"));
          return destinationAsn.country == country ? "visible" : "hidden";

        })

      }

      function revertToCountryInherit() {
        svg.select(`#${previousCountry}.country`).selectAll("path").style("visibility","inherit"); 
      }
      function revertToIXPInherit(){
        
        svg.select(`#IXP_${clickedIxp}`).style("visibility", "inherit");




        countryAsns.forEach(function (country) {
          svg.select(`#${country}.country`).selectAll(".ASN")
            .each(function (d, i) {
              if (customerAsns.includes(d.id)) {
                d3.select(this).select(".asn-dot").style("visibility", "inherit");
                d3.select(this).selectAll("path")
                .each(function(d,i){
                    var destinationAsn = asnsbyid.get(d3.select(this).attr("destination"));
                    if(customerAsns.includes(destinationAsn.id)){
                      d3.select(this).style("visibility","inherit");
                    }

                })

              }
            })


        })



      }

      //true: draws all elements on the map
      //false: removes all elements on the map
      function drawEverything(showFlag) {
        showFlag =showFlag ? "visible":"hidden";
        svg.selectAll(".country").style("visibility",showFlag);


      }

      //Modifies the IXP element so that it may be drawn on screen
      function typeIxp(d) {
        d[0] = +d.longitude;
        d[1] = +d.latitude;

        d.customers = d.customers.split(",");

        return d;
      }
      //Modifies the ASN element by converting attributes to numbers and by adding list attributes that contain the relationships that an asn has with other asns
      function typeAsn(d) {

        d[0] = +d.longitude;
        d[1] = +d.latitude;

        // d.map = JSON.parse(d.map);
        var kv_pairs = d.map.split(" ");

        //Can be improved maybe hopefully
        d.map = new Map();

        kv_pairs.forEach(function (pair) {
          split_pairs = pair.split(":");
          d.map.set(split_pairs[0], split_pairs[1]);
        })

        return d;
      }
      d3.select(self.frameElement).style("height", height + "px");

    </script>